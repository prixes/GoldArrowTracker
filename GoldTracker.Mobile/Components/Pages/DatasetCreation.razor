@page "/dataset-creation"

@using GoldTracker.Mobile.Services
@using Microsoft.JSInterop
@using SixLabors.ImageSharp.PixelFormats
@using SixLabors.ImageSharp.Processing
@inject CameraService CameraService
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject ImageProcessingService ImageProcessingService

<style>
    .archery-container {
        max-width: 600px !important;
        margin: auto;
    }
    .archery-themed-card {
        border-top: 4px solid var(--mud-palette-primary) !important;
        position: relative;
        overflow: hidden;
    }
    .archery-themed-card::after {
        content: "";
        position: absolute;
        top: -50px;
        right: -50px;
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, #FFD700 20%, #FF0000 40%, #2196F3 60%, #333333 80%, #FFFFFF 100%);
        opacity: 0.1;
        border-radius: 50%;
    }
    .image-section {
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        border: 2px solid #333;
    }
    .archery-panel {
        backdrop-filter: blur(8px);
    }
</style>

<MudContainer MaxWidth="MaxWidth.False" Class="pa-2 archery-container">
    @if (string.IsNullOrEmpty(_originalImageBase64))
    {
        <!-- Selection Screen -->
        <MudCard Elevation="0" Class="pa-4 archery-themed-card" Style="background: linear-gradient(135deg, var(--mud-palette-surface) 0%, var(--mud-palette-background-grey) 100%); border: 1px solid var(--mud-palette-lines-default); border-radius: 12px;">
            <MudCardHeader Class="pa-0 mb-4">
                <CardHeaderAvatar>
                    <MudAvatar Color="Color.Primary" Variant="Variant.Filled" Size="Size.Large">
                        <MudIcon Icon="@Icons.Material.Filled.Adjust" />
                    </MudAvatar>
                </CardHeaderAvatar>
                <CardHeaderContent>
                    <MudText Typo="Typo.h5" Class="font-weight-bold">Dataset Builder</MudText>
                    <MudText Typo="Typo.caption">Create the ultimate archery model</MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent Class="pa-0">
                <MudText Typo="Typo.body2" Class="mb-4">Select an image to start annotating targets and arrows.</MudText>
                
                @if (_isLoading)
                {
                    <MudStack AlignItems="AlignItems.Center" Class="py-8">
                        <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
                        <MudText Typo="Typo.caption">Loading Assets...</MudText>
                    </MudStack>
                }
                else
                {
                    <MudStack Spacing="2">
                        <MudButton Variant="Variant.Filled" 
                                   Color="Color.Primary" 
                                   StartIcon="@Icons.Material.Filled.PhotoCamera" 
                                   OnClick="CapturePhotoAsync" 
                                   FullWidth="true" 
                                   Size="Size.Large" 
                                   Style="text-transform:none; border-radius: 8px;">
                            Capture Target
                        </MudButton>
                        <MudButton Variant="Variant.Outlined" 
                                   Color="Color.Primary" 
                                   StartIcon="@Icons.Material.Filled.PhotoLibrary" 
                                   OnClick="PickPhotoAsync" 
                                   FullWidth="true" 
                                   Size="Size.Large" 
                                   Style="text-transform:none; border-radius: 8px;">
                            Pick from Gallery
                        </MudButton>
                        <MudButton Variant="Variant.Text" 
                                   Color="Color.Default" 
                                   StartIcon="@Icons.Material.Filled.FolderOpen" 
                                   OnClick="BrowseFilesAsync" 
                                   FullWidth="true" 
                                   Size="Size.Medium" 
                                   Style="text-transform:none;">
                            Browse Local Files
                        </MudButton>
                    </MudStack>
                }
            </MudCardContent>
        </MudCard>
    }
    else
    {
        <div class="image-section" style="position: relative; width: 100%; max-height: 65vh; background-color: transparent; border-radius: 12px; overflow: hidden; display: flex; justify-content: center; align-items: center; touch-action: none; border: 2px solid var(--mud-palette-lines-default);">
            <img @ref="_imageElement" src="@($"data:image/jpeg;base64,{_originalImageBase64}")" alt="image to annotate" style="max-width: 100%; max-height: 65vh; object-fit: contain; pointer-events: none; display: block;"/>
            <canvas @ref="_canvasElement" id="annotation-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; touch-action: none;"></canvas>
        </div>

        <MudCard Elevation="0" Class="mt-2 pa-2 archery-panel" Style="border: 1px solid var(--mud-palette-lines-default); border-radius: 12px; background-color: rgba(var(--mud-palette-surface-rgb), 0.9);">
            <MudText Typo="Typo.caption" Align="Align.Center" Class="mb-2 d-block" Style="opacity: 0.7; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;">
                — Select Object Marker First —
            </MudText>

            <div class="d-flex flex-column align-center gap-2">
                <MudButton Variant="@(_selectedMode == "target" ? Variant.Filled : Variant.Outlined)" 
                           Color="Color.Primary" 
                           StartIcon="@Icons.Material.Filled.Adjust"
                           Size="Size.Medium"
                           Class="px-6"
                           Style="height: 40px; border-radius: 20px; text-transform: none; font-weight: bold; min-width: 140px;"
                           OnClick="@(() => SetSelectedMode("target"))">
                    Target Face
                </MudButton>
                
                <div class="d-flex flex-wrap gap-1 justify-center align-center">
                    @for (int i = 10; i >= 1; i--)
                    {
                        int score = i;
                        <MudButton Variant="@(_selectedMode == "arrow" && _selectedArrowScore == score ? Variant.Filled : Variant.Outlined)"
                                   Color="@GetScoreButtonColor(score)"
                                   Size="Size.Medium"
                                   Style="min-width: 44px; width: 44px; height: 44px; border-radius: 22px; padding: 0; font-weight: bold; font-size: 1.1rem;"
                                   OnClick="@(() => SetSelectedScore(score))">
                            @score
                        </MudButton>
                    }
                    <MudButton Variant="@(_selectedMode == "arrow" && _selectedArrowScore == 0 ? Variant.Filled : Variant.Outlined)" 
                               Color="@GetScoreButtonColor(0)" 
                               Size="Size.Medium"
                               Style="min-width: 44px; width: 44px; height: 44px; border-radius: 22px; padding: 0; font-weight: bold; font-size: 1.1rem;"
                               OnClick="@(() => SetSelectedScore(0))">
                        M
                    </MudButton>
                </div>
            </div>

            <MudStack Row="true" Spacing="1" Class="mt-3">
                <MudButton Variant="Variant.Filled" Color="Color.Success" StartIcon="@Icons.Material.Filled.Save" OnClick="SaveAnnotationsAsync" Disabled="!_annotations.Any()" Size="Size.Medium" Style="flex: 1; height: 44px; border-radius: 22px; font-weight: bold; font-size: 0.9rem;">
                    Finish & Save
                </MudButton>
                <MudIconButton Icon="@Icons.Material.Filled.Undo" Color="Color.Warning" Variant="Variant.Outlined" OnClick="UndoLastAnnotation" Disabled="!_annotations.Any()" Style="width: 44px; height: 44px; border-radius: 22px;" Size="Size.Small" />
                <MudIconButton Icon="@Icons.Material.Filled.DeleteSweep" Color="Color.Error" Variant="Variant.Outlined" OnClick="ClearAnnotations" Disabled="!_annotations.Any()" Style="width: 44px; height: 44px; border-radius: 22px;" Size="Size.Small" />
            </MudStack>
            
            <MudButton Variant="Variant.Text" Color="Color.Default" FullWidth="true" OnClick="Reset" Class="mt-1" Style="text-transform: none; opacity: 0.6; font-size: 0.75rem; min-height: 24px;">
                Cancel
            </MudButton>
        </MudCard>
    }
</MudContainer>

@code {
    private string? _originalImagePath;
    private byte[]? _originalImageBytes;
    private string _originalImageBase64 = string.Empty;
    
    private bool _isLoading = false;
    private bool _isLoaded = false;

    private ElementReference _imageElement;
    private ElementReference _canvasElement;
    private DotNetObjectReference<DatasetCreation> _dotNetObjectReference = null!;

    private string _selectedMode = "target";
    private int _selectedArrowScore = 10;
    private List<Annotation> _annotations = new();
    private string[] _loadedClassLabels = Array.Empty<string>();
    private string[] _loadedClassColors = Array.Empty<string>();

    public class Annotation
    {
        public int ClassId { get; set; }
        public double StartX { get; set; }
        public double StartY { get; set; }
        public double EndX { get; set; }
        public double EndY { get; set; }
    }

    protected override void OnInitialized()
    {
        _dotNetObjectReference = DotNetObjectReference.Create(this);
        
        // Populate _loadedClassLabels and _loadedClassColors from ImageProcessingService.ObjectDetectionConfig.ClassLabels
        var classLabelsDict = ImageProcessingService.ObjectDetectionConfig.ClassLabels;
        var maxClassId = classLabelsDict.Keys.Any() ? classLabelsDict.Keys.Max() : -1;
        _loadedClassLabels = new string[maxClassId + 1];
        _loadedClassColors = new string[maxClassId + 1];

        for (int i = 0; i <= maxClassId; i++)
        {
            if (classLabelsDict.TryGetValue(i, out var label))
            {
                _loadedClassLabels[i] = label;
            }
            else
            {
                _loadedClassLabels[i] = $"unknown_{i}";
            }
            _loadedClassColors[i] = GetHexColor(i);
        }
    }

    private string GetHexColor(int classId)
    {
        return classId switch
        {
            11 => "#AA00FF", // Target - Purple
            10 or 9 => "#FFD700", // Gold
            8 or 7 => "#FF0000", // Red
            6 or 5 => "#2196F3", // Blue
            4 or 3 => "#333333", // Black
            _ => "#9E9E9E" // White/Other
        };
    }
    
    private Color GetScoreButtonColor(int score)
    {
        return score switch
        {
            10 or 9 => Color.Warning,
            8 or 7 => Color.Error,
            6 or 5 => Color.Info,
            4 or 3 => Color.Dark,
            _ => Color.Surface
        };
    }

    private void SetSelectedMode(string mode)
    {
        _selectedMode = mode;
        StateHasChanged();
    }

    private void SetSelectedScore(int score)
    {
        _selectedMode = "arrow";
        _selectedArrowScore = score;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!string.IsNullOrEmpty(_originalImageBase64) && !_isLoaded)
        {
            _isLoaded = true;
            Console.WriteLine("[DatasetCreation] Initializing annotator with canvas and image elements.");
            await JSRuntime.InvokeVoidAsync("annotator.init", _canvasElement, _imageElement, _dotNetObjectReference);
        }
    }

    private async Task CapturePhotoAsync()
    {
        if (_isLoading) return;
        _isLoading = true;
        try
        {
            var hasPermission = await CameraService.RequestCameraPermissionAsync();
            if (!hasPermission) { Snackbar.Add("Camera permission denied", Severity.Error); return; }

            var imagePath = await CameraService.CapturePhotoAsync();
            if (string.IsNullOrEmpty(imagePath)) { Snackbar.Add("Cancelled", Severity.Info); return; }

            await LoadImageAsync(imagePath);
        }
        finally { _isLoading = false; }
    }

    private async Task PickPhotoAsync()
    {
        if (_isLoading) return;
        _isLoading = true;
        try
        {
            var imagePath = await CameraService.PickPhotoAsync();
            if (string.IsNullOrEmpty(imagePath)) { Snackbar.Add("Cancelled", Severity.Info); return; }

            await LoadImageAsync(imagePath);
        }
        finally { _isLoading = false; }
    }

    private async Task BrowseFilesAsync()
    {
        if (_isLoading) return;
        _isLoading = true;
        try
        {
            var imagePath = await CameraService.PickMediaAsync();
            if (string.IsNullOrEmpty(imagePath)) { Snackbar.Add("Cancelled", Severity.Info); return; }

            await LoadImageAsync(imagePath);
        }
        finally { _isLoading = false; }
    }

    private async Task LoadImageAsync(string imagePath)
    {
        try
        {
            _originalImagePath = imagePath;
            _originalImageBytes = await System.IO.File.ReadAllBytesAsync(imagePath);
            _originalImageBase64 = Convert.ToBase64String(_originalImageBytes);
            Console.WriteLine($"[DatasetCreation] Image loaded. Base64 length: {_originalImageBase64.Length}");
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading image: {ex.Message}", Severity.Error);
            _originalImagePath = null;
            _originalImageBytes = null;
            Console.WriteLine($"[DatasetCreation] Error loading image: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task AddBox(double startX, double startY, double endX, double endY)
    {
        int classId = _selectedMode == "target" ? 11 : _selectedArrowScore;
        
        var annotation = new Annotation
        {
            ClassId = classId,
            StartX = startX,
            StartY = startY,
            EndX = endX,
            EndY = endY
        };
        _annotations.Add(annotation);
        
        var boxJs = new {
            startX = startX,
            startY = startY,
            endX = endX,
            endY = endY,
            label = _loadedClassLabels[classId],
            color = _loadedClassColors[classId]
        };

        await JSRuntime.InvokeVoidAsync("annotator.addBox", boxJs);
        StateHasChanged();
    }
    
    private async Task SaveAnnotationsAsync()
    {
        if (_originalImageBytes == null || !_annotations.Any())
        {
            Snackbar.Add("No annotations to save.", Severity.Warning);
            return;
        }

        try
        {
            var hasPermission = await CameraService.RequestStorageWritePermissionAsync();
            if (!hasPermission)
            {
                Snackbar.Add("Storage permission denied.", Severity.Error);
                return;
            }

            // Show processing message
            Snackbar.Add("Processing images... This may take a moment.", Severity.Info);

            var timestamp = $"{DateTime.Now:yyyyMMdd_HHmmssfff}";

            // --- 1. Macro Model (Targets) ---
            var macroImageDir = Path.Combine("Export", "Macro_Model", "images");
            var macroLabelDir = Path.Combine("Export", "Macro_Model", "labels");

            // Filter for targets (Class 11)
            var targets = _annotations.Where(a => a.ClassId == 11).ToList();
            var targetStrings = new List<string>();
            foreach (var t in targets)
            {
                var x_center = (t.StartX + t.EndX) / 2.0;
                var y_center = (t.StartY + t.EndY) / 2.0;
                var width = t.EndX - t.StartX;
                var height = t.EndY - t.StartY;
                targetStrings.Add($"0 {x_center:F6} {y_center:F6} {width:F6} {height:F6}"); 
            }

            if (targetStrings.Any())
            {
                var macroImagePath = await CameraService.SaveImageAsync(_originalImageBytes, $"{timestamp}.jpg", macroImageDir);
                if (!string.IsNullOrEmpty(macroImagePath))
                {
                    var macroLabelPath = Path.Combine(Path.GetDirectoryName(macroImagePath)!.Replace("images", "labels"), $"{timestamp}.txt");
                    Directory.CreateDirectory(Path.GetDirectoryName(macroLabelPath)!);
                    await File.WriteAllTextAsync(macroLabelPath, string.Join("\n", targetStrings));
                    CameraService.TriggerMediaScanner(macroLabelPath);
                }
            }

            // --- 2. Micro Model (Arrows + Target Refinement) ---
            // OPTIMIZATION: Use Android-native Bitmap APIs for 10-20x faster performance
            if (targets.Any())
            {
                // Run on background thread to prevent UI blocking during image load & crop operations
                await Task.Run(async () =>
                {
                    try
                    {
                        Console.WriteLine($"[DatasetCreation] Starting micro model processing for {targets.Count} target(s)...");
                        
                        var microImageDir = Path.Combine("Export", "Micro_Model", "images");
                        var microLabelDir = Path.Combine("Export", "Micro_Model", "labels");
                        
                        double padding = 0.05; // 5% padding

#if ANDROID
                        // Use Android-native Bitmap APIs (SUPER FAST - with better EXIF support)
                        Console.WriteLine($"[DatasetCreation] Loading bitmap with Android-native API from {_originalImagePath}...");
                        using var sourceBitmap = await GoldTracker.Mobile.Platforms.Android.AndroidImageProcessor.LoadBitmapAsync(_originalImageBytes, _originalImagePath);
                        
                        if (sourceBitmap == null)
                        {
                            Console.WriteLine($"[DatasetCreation] ERROR: Failed to load bitmap");
                            return;
                        }

                        Console.WriteLine($"[DatasetCreation] Loaded source bitmap: {sourceBitmap.Width}x{sourceBitmap.Height}");
#else
                        // Fallback to ImageSharp for other platforms
                        using var sourceImage = SixLabors.ImageSharp.Image.Load<Rgba32>(_originalImageBytes);
                        sourceImage.Mutate(x => x.AutoOrient());
                        
                        Console.WriteLine($"[DatasetCreation] Loaded source image: {sourceImage.Width}x{sourceImage.Height}");
#endif

                        int cropIndex = 0;
                        foreach (var t in targets)
                        {
                            cropIndex++;
                            var cropFileName = $"{timestamp}_crop{cropIndex}";

                            // Calculate PADDED boundaries
                            double tW_raw = t.EndX - t.StartX;
                            double tH_raw = t.EndY - t.StartY;
                            
                            double padX = tW_raw * padding;
                            double padY = tH_raw * padding;

                            double cropStartX = Math.Max(0, t.StartX - padX);
                            double cropStartY = Math.Max(0, t.StartY - padY);
                            double cropEndX = Math.Min(1, t.EndX + padX);
                            double cropEndY = Math.Min(1, t.EndY + padY);

                            double cropW = cropEndX - cropStartX;
                            double cropH = cropEndY - cropStartY;

                            Console.WriteLine($"[DatasetCreation] Processing Target Crop {cropIndex}/{targets.Count}:");
                            Console.WriteLine($"  Original Box: {t.StartX:F4}, {t.StartY:F4} to {t.EndX:F4}, {t.EndY:F4}");
                            Console.WriteLine($"  Padded Box:   {cropStartX:F4}, {cropStartY:F4} to {cropEndX:F4}, {cropEndY:F4}");
                            Console.WriteLine($"  Crop Norm:    X={cropStartX:F4}, Y={cropStartY:F4}, W={cropW:F4}, H={cropH:F4}");
                            
                            if (cropW > 0.9 || cropH > 0.9)
                            {
                                Console.WriteLine("  [WARNING] Crop covers >90% of the image. It may look like the original image.");
                            }

                            // 2.1 Crop Image (Padded)
                            byte[] cropBytes;
#if ANDROID
                            // Use Android-native cropping (MUCH faster!)
                            cropBytes = await GoldTracker.Mobile.Platforms.Android.AndroidImageProcessor.CropBitmapAsync(
                                sourceBitmap,
                                cropStartX, cropStartY, 
                                cropW, cropH, 
                                quality: 100);
#else
                            // Fallback to ImageSharp
                            cropBytes = await ImageProcessingService.CropImageAsync(
                                sourceImage,
                                cropStartX, cropStartY, 
                                cropW, cropH).ConfigureAwait(false);
#endif

                            if (cropBytes.Length == 0)
                            {
                                Console.WriteLine($"  [WARNING] Crop {cropIndex} resulted in empty bytes, skipping.");
                                continue;
                            }

                            Console.WriteLine($"  Crop bytes generated: {cropBytes.Length} bytes");

                            // 2.2 Save Crop
                            var microImagePath = await CameraService.SaveImageAsync(cropBytes, $"{cropFileName}.jpg", microImageDir).ConfigureAwait(false);
                            if (string.IsNullOrEmpty(microImagePath))
                            {
                                Console.WriteLine($"  [WARNING] Failed to save crop {cropIndex}, skipping.");
                                continue;
                            }

                            Console.WriteLine($"  Saved crop image: {microImagePath}");

                            // 2.3 Generate Labels for this Crop
                            var microStrings = new List<string>();

                            // A. Add the Target itself (Class 11) relative to this padded crop
                            var tCenterX = (t.StartX + t.EndX) / 2.0;
                            var tCenterY = (t.StartY + t.EndY) / 2.0;

                            var tLocalX = (tCenterX - cropStartX) / cropW;
                            var tLocalY = (tCenterY - cropStartY) / cropH;
                            var tLocalW = tW_raw / cropW;
                            var tLocalH = tH_raw / cropH;
                            
                            microStrings.Add($"11 {tLocalX:F6} {tLocalY:F6} {tLocalW:F6} {tLocalH:F6}");

                            // B. Add Arrows (Classes 0-10) relative to this padded crop
                            var validArrows = _annotations
                                .Where(a => a.ClassId != 11) // Arrows
                                .Where(a => {
                                    var cX = (a.StartX + a.EndX) / 2.0;
                                    var cY = (a.StartY + a.EndY) / 2.0;
                                    return cX >= cropStartX && cX <= cropEndX && cY >= cropStartY && cY <= cropEndY;
                                });

                            foreach (var a in validArrows)
                            {
                                var aCenterX = (a.StartX + a.EndX) / 2.0;
                                var aCenterY = (a.StartY + a.EndY) / 2.0;
                                var aW = a.EndX - a.StartX;
                                var aH = a.EndY - a.StartY;

                                // Transform to local crop coordinates
                                var x_local = (aCenterX - cropStartX) / cropW;
                                var y_local = (aCenterY - cropStartY) / cropH;
                                var w_local = aW / cropW;
                                var h_local = aH / cropH;

                                microStrings.Add($"{a.ClassId} {x_local:F6} {y_local:F6} {w_local:F6} {h_local:F6}");
                            }

                            // 2.4 Save Micro Labels
                            if (microStrings.Any())
                            {
                                var microLabelPath = Path.Combine(Path.GetDirectoryName(microImagePath)!.Replace("images", "labels"), $"{cropFileName}.txt");
                                Directory.CreateDirectory(Path.GetDirectoryName(microLabelPath)!);
                                
                                await File.WriteAllTextAsync(microLabelPath, string.Join("\n", microStrings)).ConfigureAwait(false);
                                CameraService.TriggerMediaScanner(microLabelPath);
                                Console.WriteLine($"  Saved crop labels: {microLabelPath}");
                            }
                            
                            Console.WriteLine($"[DatasetCreation] ✓ Completed crop {cropIndex}/{targets.Count}");
                        }
                        
                        Console.WriteLine($"[DatasetCreation] ✓ All {targets.Count} crop(s) processed successfully!");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[DatasetCreation] ERROR in micro processing: {ex.Message}");
                        Console.WriteLine($"[DatasetCreation] Stack trace: {ex.StackTrace}");
                        // Note: Can't use Snackbar from background thread
                        throw;
                    }
                });  // Removed ConfigureAwait(false) - we WANT to return to UI thread after this
            }
            else
            {
                Console.WriteLine($"[DatasetCreation] No targets found, skipping micro model processing.");
            }

            Snackbar.Add($"Saved hierarchical dataset to Export/", Severity.Success);
            Reset();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving annotations: {ex.Message}", Severity.Error);
            Console.WriteLine($"[DatasetCreation] Error: {ex}");
        }
    }

    private void UndoLastAnnotation()
    {
        if (_annotations.Any())
        {
            _annotations.RemoveAt(_annotations.Count - 1);
            JSRuntime.InvokeVoidAsync("annotator.removeLastBox");
            StateHasChanged();
        }
    }

    private void ClearAnnotations()
    {
        _annotations.Clear();
        JSRuntime.InvokeVoidAsync("annotator.clear");
        StateHasChanged();
    }

    private void Reset()
    {
        _originalImagePath = null;
        _originalImageBase64 = string.Empty;
        _originalImageBytes = null;
        _annotations.Clear();
        _isLoaded = false;
        StateHasChanged();
    }

    public void Dispose()
    {
        _dotNetObjectReference?.Dispose();
        if (_isLoaded)
        {
            JSRuntime.InvokeVoidAsync("annotator.destroy");
        }
    }


}