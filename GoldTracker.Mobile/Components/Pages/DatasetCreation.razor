@page "/dataset-creation"

@using GoldTracker.Mobile.Services
@using Microsoft.JSInterop
@inject CameraService CameraService
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject ImageProcessingService ImageProcessingService

<MudContainer MaxWidth="MaxWidth.Small">
    @if (string.IsNullOrEmpty(_originalImageBase64))
    {
        <!-- Selection Screen -->
        <MudPaper Elevation="0" Class="px-4 py-6">
            <MudText Typo="Typo.h3" GutterBottom="true" Class="font-weight-bold">
                Create Dataset
            </MudText>
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mb-6">
                Take or select a photo to create annotations for Object Detection training.
            </MudText>

            @if (_isLoading)
            {
                <MudText Align="Align.Center" Class="mt-4">Loading...</MudText>
                <MudProgressLinear Indeterminate="true" Class="mt-2" />
            }
            else
            {
                <MudStack Spacing="3">
                    <div Class="cursor-pointer d-flex align-center gap-4 px-4 py-3" @onclick="CapturePhotoAsync" Style="transition: all 0.2s ease; border-radius: 6px; border: 1px solid var(--mud-palette-lines-default); background-color: var(--mud-palette-surface);">
                        <MudStack Style="flex: 1;">
                            <MudText Typo="Typo.h6" Class="font-weight-bold">Take Photo</MudText>
                            <MudText Typo="Typo.body2" Color="Color.Default">Capture an image</MudText>
                        </MudStack>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" Disabled="_isLoading">Capture</MudButton>
                    </div>

                    <div Class="cursor-pointer d-flex align-center gap-4 px-4 py-3" @onclick="PickPhotoAsync" Style="transition: all 0.2s ease; border-radius: 6px; border: 1px solid var(--mud-palette-lines-default); background-color: var(--mud-palette-surface);">
                        <MudStack Style="flex: 1;">
                            <MudText Typo="Typo.h6" Class="font-weight-bold">From Gallery</MudText>
                            <MudText Typo="Typo.body2" Color="Color.Default">Select from gallery</MudText>
                        </MudStack>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" Disabled="_isLoading">Select</MudButton>
                    </div>
                </MudStack>
            }
        </MudPaper>
    }
    else
    {
        <MudPaper Elevation="0" Class="px-4 py-6">
            <div class="image-container" style="position: relative; margin-bottom: 24px; background-color: #f0f0f0; border-radius: 8px; overflow: hidden; display: flex; justify-content: center; align-items: center; touch-action: none;">
                <img @ref="_imageElement" src="@($"data:image/jpeg;base64,{_originalImageBase64}")" alt="image to annotate" style="max-width: 100%; height: auto; display: block; pointer-events: none;"/>
                <canvas @ref="_canvasElement" id="annotation-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; touch-action: none;"></canvas>
            </div>

            <MudText Typo="Typo.h6" Class="mb-3">Select Object Class:</MudText>
            
            <MudButton Variant="@(_selectedMode == "target" ? Variant.Filled : Variant.Outlined)" 
                       Color="Color.Primary" 
                       FullWidth="true" 
                       Class="mb-4 py-2"
                       OnClick="@(() => SetSelectedMode("target"))">
                Target Face
            </MudButton>

            <MudText Typo="Typo.subtitle2" Class="mb-2">Arrow Score:</MudText>
            <MudGrid Spacing="1" Class="mb-6">
                @for (int i = 10; i >= 0; i--)
                {
                    int score = i;
                    <MudItem xs="3">
                        <MudButton Variant="@(_selectedMode == "arrow" && _selectedArrowScore == score ? Variant.Filled : Variant.Outlined)" 
                                   Color="@GetScoreButtonColor(score)" 
                                   FullWidth="true"
                                   Size="Size.Small"
                                   OnClick="@(() => SetSelectedScore(score))">
                            @score
                        </MudButton>
                    </MudItem>
                }
                <MudItem xs="3">
                    <MudText Align="Align.Center" Class="mt-2" Typo="Typo.caption" Style="opacity: 0.6">Grid: 0-10</MudText>
                </MudItem>
            </MudGrid>

            <MudStack Spacing="2" Class="mt-6">
                <MudButton Variant="Variant.Filled" Color="Color.Success" FullWidth="true" Size="Size.Large" OnClick="SaveAnnotationsAsync" Disabled="!_annotations.Any()">
                    Finish & Save
                </MudButton>
                <div class="d-flex gap-2">
                    <MudButton Variant="Variant.Outlined" Color="Color.Secondary" FullWidth="true" OnClick="UndoLastAnnotation" Disabled="!_annotations.Any()">
                        Undo
                    </MudButton>
                    <MudButton Variant="Variant.Outlined" Color="Color.Error" FullWidth="true" OnClick="ClearAnnotations" Disabled="!_annotations.Any()">
                        Clear All
                    </MudButton>
                </div>
                <MudButton Variant="Variant.Text" Color="Color.Default" FullWidth="true" OnClick="Reset" Class="mt-2">
                    Back / New Photo
                </MudButton>
            </MudStack>
        </MudPaper>
    }
</MudContainer>

@code {
    private string? _originalImagePath;
    private byte[]? _originalImageBytes;
    private string _originalImageBase64 = string.Empty;
    
    private bool _isLoading = false;
    private bool _isLoaded = false;

    private ElementReference _imageElement;
    private ElementReference _canvasElement;
    private DotNetObjectReference<DatasetCreation> _dotNetObjectReference = null!;

    private string _selectedMode = "target";
    private int _selectedArrowScore = 10;
    private List<Annotation> _annotations = new();
    private string[] _loadedClassLabels = Array.Empty<string>();
    private string[] _loadedClassColors = Array.Empty<string>();

    public class Annotation
    {
        public int ClassId { get; set; }
        public double StartX { get; set; }
        public double StartY { get; set; }
        public double EndX { get; set; }
        public double EndY { get; set; }
    }

    protected override void OnInitialized()
    {
        _dotNetObjectReference = DotNetObjectReference.Create(this);
        
        // Populate _loadedClassLabels and _loadedClassColors from ImageProcessingService.ObjectDetectionConfig.ClassLabels
        var classLabelsDict = ImageProcessingService.ObjectDetectionConfig.ClassLabels;
        var maxClassId = classLabelsDict.Keys.Any() ? classLabelsDict.Keys.Max() : -1;
        _loadedClassLabels = new string[maxClassId + 1];
        _loadedClassColors = new string[maxClassId + 1];

        for (int i = 0; i <= maxClassId; i++)
        {
            if (classLabelsDict.TryGetValue(i, out var label))
            {
                _loadedClassLabels[i] = label;
            }
            else
            {
                _loadedClassLabels[i] = $"unknown_{i}";
            }
            _loadedClassColors[i] = GetHexColor(i);
        }
    }

    private string GetHexColor(int classId)
    {
        return classId switch
        {
            11 => "#AA00FF", // Target - Purple
            10 or 9 => "#FFD700", // Gold
            8 or 7 => "#FF0000", // Red
            6 or 5 => "#2196F3", // Blue
            4 or 3 => "#333333", // Black
            _ => "#9E9E9E" // White/Other
        };
    }
    
    private Color GetScoreButtonColor(int score)
    {
        return score switch
        {
            10 or 9 => Color.Warning,
            8 or 7 => Color.Error,
            6 or 5 => Color.Info,
            4 or 3 => Color.Dark,
            _ => Color.Surface
        };
    }

    private void SetSelectedMode(string mode)
    {
        _selectedMode = mode;
        StateHasChanged();
    }

    private void SetSelectedScore(int score)
    {
        _selectedMode = "arrow";
        _selectedArrowScore = score;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!string.IsNullOrEmpty(_originalImageBase64) && !_isLoaded)
        {
            _isLoaded = true;
            Console.WriteLine("[DatasetCreation] Initializing annotator with canvas and image elements.");
            await JSRuntime.InvokeVoidAsync("annotator.init", _canvasElement, _imageElement, _dotNetObjectReference);
        }
    }

    private async Task CapturePhotoAsync()
    {
        if (_isLoading) return;
        _isLoading = true;
        try
        {
            var hasPermission = await CameraService.RequestCameraPermissionAsync();
            if (!hasPermission) { Snackbar.Add("Camera permission denied", Severity.Error); return; }

            var imagePath = await CameraService.CapturePhotoAsync();
            if (string.IsNullOrEmpty(imagePath)) { Snackbar.Add("Cancelled", Severity.Info); return; }

            await LoadImageAsync(imagePath);
        }
        finally { _isLoading = false; }
    }

    private async Task PickPhotoAsync()
    {
        if (_isLoading) return;
        _isLoading = true;
        try
        {
            var imagePath = await CameraService.PickPhotoAsync();
            if (string.IsNullOrEmpty(imagePath)) { Snackbar.Add("Cancelled", Severity.Info); return; }

            await LoadImageAsync(imagePath);
        }
        finally { _isLoading = false; }
    }

    private async Task LoadImageAsync(string imagePath)
    {
        try
        {
            _originalImagePath = imagePath;
            _originalImageBytes = await System.IO.File.ReadAllBytesAsync(imagePath);
            _originalImageBase64 = Convert.ToBase64String(_originalImageBytes);
            Console.WriteLine($"[DatasetCreation] Image loaded. Base64 length: {_originalImageBase64.Length}");
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading image: {ex.Message}", Severity.Error);
            _originalImagePath = null;
            _originalImageBytes = null;
            Console.WriteLine($"[DatasetCreation] Error loading image: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task AddBox(double startX, double startY, double endX, double endY)
    {
        int classId = _selectedMode == "target" ? 11 : _selectedArrowScore;
        
        var annotation = new Annotation
        {
            ClassId = classId,
            StartX = startX,
            StartY = startY,
            EndX = endX,
            EndY = endY
        };
        _annotations.Add(annotation);
        
        var boxJs = new {
            startX = startX,
            startY = startY,
            endX = endX,
            endY = endY,
            label = _loadedClassLabels[classId],
            color = _loadedClassColors[classId]
        };

        await JSRuntime.InvokeVoidAsync("annotator.addBox", boxJs);
        StateHasChanged();
    }
    
    private async Task SaveAnnotationsAsync()
    {
        if (_originalImageBytes == null || !_annotations.Any())
        {
            Snackbar.Add("No annotations to save.", Severity.Warning);
            return;
        }

        try
        {
            var hasPermission = await CameraService.RequestStorageWritePermissionAsync();
            if (!hasPermission)
            {
                Snackbar.Add("Storage permission denied.", Severity.Error);
                return;
            }

            var timestamp = $"{DateTime.Now:yyyyMMdd_HHmmssfff}";

            // --- 1. Macro Model (Targets) ---
            var macroImageDir = Path.Combine("Export", "Macro_Model", "images");
            var macroLabelDir = Path.Combine("Export", "Macro_Model", "labels");

            // Filter for targets (Class 11)
            var targets = _annotations.Where(a => a.ClassId == 11).ToList();
            var targetStrings = new List<string>();
            foreach (var t in targets)
            {
                var x_center = (t.StartX + t.EndX) / 2.0;
                var y_center = (t.StartY + t.EndY) / 2.0;
                var width = t.EndX - t.StartX;
                var height = t.EndY - t.StartY;
                targetStrings.Add($"0 {x_center:F6} {y_center:F6} {width:F6} {height:F6}"); 
            }

            if (targetStrings.Any())
            {
                var macroImagePath = await CameraService.SaveImageAsync(_originalImageBytes, $"{timestamp}.jpg", macroImageDir);
                if (!string.IsNullOrEmpty(macroImagePath))
                {
                    var macroLabelPath = Path.Combine(Path.GetDirectoryName(macroImagePath)!.Replace("images", "labels"), $"{timestamp}.txt");
                    Directory.CreateDirectory(Path.GetDirectoryName(macroLabelPath)!);
                    await File.WriteAllTextAsync(macroLabelPath, string.Join("\n", targetStrings));
                    CameraService.TriggerMediaScanner(macroLabelPath);
                }
            }

            // --- 2. Micro Model (Arrows + Target Refinement) ---
            var microImageDir = Path.Combine("Export", "Micro_Model", "images");
            var microLabelDir = Path.Combine("Export", "Micro_Model", "labels");
            
            // Get natural image size for boundary checks (approximate from annotations if needed, but safer to assume normalized)
            // Annotations are normalized 0-1, so boundaries are 0 and 1.
            double padding = 0.05; // 5% padding

            int cropIndex = 0;
            foreach (var t in targets)
            {
                cropIndex++;
                var cropFileName = $"{timestamp}_crop{cropIndex}";

                // Calculate PADDED boundaries
                double tW_raw = t.EndX - t.StartX;
                double tH_raw = t.EndY - t.StartY;
                
                double padX = tW_raw * padding;
                double padY = tH_raw * padding;

                double cropStartX = Math.Max(0, t.StartX - padX);
                double cropStartY = Math.Max(0, t.StartY - padY);
                double cropEndX = Math.Min(1, t.EndX + padX);
                double cropEndY = Math.Min(1, t.EndY + padY);

                double cropW = cropEndX - cropStartX;
                double cropH = cropEndY - cropStartY;

                Console.WriteLine($"[DatasetCreation] Processing Target Crop {cropIndex}:");
                Console.WriteLine($"  Original Box: {t.StartX:F4}, {t.StartY:F4} to {t.EndX:F4}, {t.EndY:F4}");
                Console.WriteLine($"  Padded Box:   {cropStartX:F4}, {cropStartY:F4} to {cropEndX:F4}, {cropEndY:F4}");
                Console.WriteLine($"  Crop Norm:    X={cropStartX:F4}, Y={cropStartY:F4}, W={cropW:F4}, H={cropH:F4}");
                
                if (cropW > 0.9 || cropH > 0.9)
                {
                    Console.WriteLine("  [WARNING] Crop covers >90% of the image. It may look like the original image.");
                }

                // 2.1 Crop Image (Padded)
                var cropBytes = await ImageProcessingService.CropImageAsync(
                    _originalImageBytes, 
                    cropStartX, cropStartY, 
                    cropW, cropH);

                if (cropBytes.Length == 0) continue;

                // 2.2 Save Crop
                var microImagePath = await CameraService.SaveImageAsync(cropBytes, $"{cropFileName}.jpg", microImageDir);
                if (string.IsNullOrEmpty(microImagePath)) continue;

                // 2.3 Generate Labels for this Crop
                var microStrings = new List<string>();

                // A. Add the Target itself (Class 11) relative to this padded crop
                // This helps the micro model find the center/structure
                var tCenterX = (t.StartX + t.EndX) / 2.0;
                var tCenterY = (t.StartY + t.EndY) / 2.0;

                var tLocalX = (tCenterX - cropStartX) / cropW;
                var tLocalY = (tCenterY - cropStartY) / cropH;
                var tLocalW = tW_raw / cropW;
                var tLocalH = tH_raw / cropH;
                
                microStrings.Add($"11 {tLocalX:F6} {tLocalY:F6} {tLocalW:F6} {tLocalH:F6}");


                // B. Add Arrows (Classes 0-10) relative to this padded crop
                // We include all arrows that fall inside the crop boundaries
                var validArrows = _annotations
                    .Where(a => a.ClassId != 11) // Arrows
                    .Where(a => {
                        var cX = (a.StartX + a.EndX) / 2.0;
                        var cY = (a.StartY + a.EndY) / 2.0;
                        return cX >= cropStartX && cX <= cropEndX && cY >= cropStartY && cY <= cropEndY;
                    });

                foreach (var a in validArrows)
                {
                    var aCenterX = (a.StartX + a.EndX) / 2.0;
                    var aCenterY = (a.StartY + a.EndY) / 2.0;
                    var aW = a.EndX - a.StartX;
                    var aH = a.EndY - a.StartY;

                    // Transform to local crop coordinates
                    var x_local = (aCenterX - cropStartX) / cropW;
                    var y_local = (aCenterY - cropStartY) / cropH;
                    var w_local = aW / cropW;
                    var h_local = aH / cropH;

                    microStrings.Add($"{a.ClassId} {x_local:F6} {y_local:F6} {w_local:F6} {h_local:F6}");
                }

                // 2.4 Save Micro Labels
                if (microStrings.Any())
                {
                    var microLabelPath = Path.Combine(Path.GetDirectoryName(microImagePath)!.Replace("images", "labels"), $"{cropFileName}.txt");
                    Directory.CreateDirectory(Path.GetDirectoryName(microLabelPath)!);
                    
                    await File.WriteAllTextAsync(microLabelPath, string.Join("\n", microStrings));
                    CameraService.TriggerMediaScanner(microLabelPath);
                }
            }

            Snackbar.Add($"Saved hierarchical dataset to Export/", Severity.Success);
            Reset();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving annotations: {ex.Message}", Severity.Error);
            Console.WriteLine($"[DatasetCreation] Error: {ex}");
        }
    }

    private void UndoLastAnnotation()
    {
        if (_annotations.Any())
        {
            _annotations.RemoveAt(_annotations.Count - 1);
            JSRuntime.InvokeVoidAsync("annotator.removeLastBox");
            StateHasChanged();
        }
    }

    private void ClearAnnotations()
    {
        _annotations.Clear();
        JSRuntime.InvokeVoidAsync("annotator.clear");
        StateHasChanged();
    }

    private void Reset()
    {
        _originalImagePath = null;
        _originalImageBase64 = string.Empty;
        _originalImageBytes = null;
        _annotations.Clear();
        _isLoaded = false;
        StateHasChanged();
    }

    public void Dispose()
    {
        _dotNetObjectReference?.Dispose();
        if (_isLoaded)
        {
            JSRuntime.InvokeVoidAsync("annotator.destroy");
        }
    }

    private class ImageSize {
        public double Width {get; set;}
        public double Height {get; set;}
    }
}